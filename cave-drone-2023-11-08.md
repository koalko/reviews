# Cave drone frontend test task review (2023/11/08)

- Readme: как запускать? как играть?
- Неопрятное форматирование:
    - лишние пустые строчки
    - пробелы/табы в конце строк
    - лишние точки с запятой в конце определений функций (например, `initWebSocket`)
    - лишние точки с запятой в конце блока кода (например, `onUserSubmit`)
    - опечатки (`isStringEmty` -> `isStringEmpty`); можно использовать плагин [cSpell](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker), чтобы легче их находить
    - неконсистентные пробелы:
      - `{id:0}` vs `{ name : newName}`
      - "съехавшее" форматирование JSX в некоторых компонентах, например `WinComponent.tsx`
      - совет: использовать Prettier для авто-форматирования и ESLint для детекта более сложных проблем в коде; обязательно запускать и то, и другое перед коммитом (лучше через коммит-хуки)
- Используется `let` там, где лучше использовать `const` (примеры: `trimmedArr`, `oldHighscores`); подобные проблемы легко детектятся ESLint, про который я уже писал выше
- Неочевидные/неподходящие имена переменных/функций; примеры:
  - `sliceYCoord`: из названия непонятно, что делает
  - `el` и `elPr` в `findPointsInbetween`: слишком сокращённые названия, делают код плохочитаемым, непонятным
- Функции типа `findPointsInbetween` стоит либо документировать комментариями по блокам (типа "этот блок делает вот это"), либо разбивать на функции поменьше с подходящими названиями
- Сам механизм детекта коллизий через `findPointsInbetween` любопытный, но неоптимальный: слишком много внутренних циклов. Проще было бы идти один раз по `y`-координате, и искать все возможные пересечения линий без создания массива точек. Canvas для этого лучше не использовать, это медленно (вызов DOM-методов канваса): идеально было бы считать через математические формулы прямых, ведь все координаты у нас уже есть. Тут опять же приходим к тому, что важно разделять логику и отображение. И логика не должна зависеть от отображения, а при таком механизме детекта коллизий зависит. Более грамотный подход: отображение вытекает из логики.
- Иногда допустимо выносить какие-то уж совсем общие функции в файлы типа `utils.tsx`, но в целом подобные названия модулей (`utils`, `tools`, т.п.) очень сильно не приветствуются. Лучше создавать в папке `utils` под-модули под конкретные нужды с соотв. названиями. Например: `utils/geometry.tsx`, `utils/storage.tsx`, т.п.
- Все `useEffect`-хуки должны описывать все свои зависимости. Это опять же лучше проверять через ESLint, он это подсвечивает. Когда начинаешь прописывать зависимости, это часто приводит к лучшему пониманию того, что реально происходит в хуке, и позволяет корректнее писать код. В целом, `useEffect` достаточно хитрая штука, про него лучше детально почитать [всё, что есть в доках](https://react.dev/reference/react/useEffect).
- Пример проблем с хуком `useEffect` в `modules/startMenu/StartMenuComponent.tsx`:
  - `if` на всё тело хука проще переделать в что-то типа `if (!token) return;`
  - Это немного продвинутый уровень, но у нас обращают на такое внимание: опять же сильное смешение уровней абстракций. Код, обслуживающий сокет, лучше всего выносить куда-то в сервисную функцию в `api`, принимающую необходимые коллбеки
  - Нужно избегать "магических" чисел/строк в коде (что такое `80`? почему `80`? такое стоит выносить в понятно именованную константу)
  - Почитай про [custom hooks](https://react.dev/reference/react/useEffect#wrapping-effects-in-custom-hooks)
  - Нет функции очистки (cleanup function); в этом коде в такой функции правильно было бы закрывать сокет (лучше всего через слой `api`-абстракции)
  - Список зависимостей некорректный (см. выше)
- Стоит использовать интерполяцию строк, например вместо `'/token/' + (i+1)` лучше писать `` `/token/${i + 1}` ``
- Функцию `isStringEmty` можно переписать сильно проще: `const isStringEmpty = (s: string) => s.trim().length < 1;`. Вообще это важный паттерн – не делать лишних `if` там, где можно просто вернуть булево значение
- В JSX компонента `StartMenuComponent` вручную создаются 10 почти одинаковых `radio-input`ов. Такие вещи обязательно нужно генерировать через `map`, без повторений в коде. Это очень важный признак неопытности разработчика: честно говоря, одной такой детали часто бывает достаточно, чтобы на собес не позвали.
- Для форматирования DOM-блоков не стоит использовать `<br />` (это очень негибкий подход); нужно разбивать на блоки и задавать отступы
- Адреса серверных URL не должны быть прописаны в коде; их нужно конфигурировать через переменные окружения ([для Vite там своя специфика](https://vitejs.dev/guide/env-and-mode.html#env-variables))
- Штуки типа `testScoreList` не должны попадать в итоговый код
- Логирование через `console.log` тоже лучше всего убирать из итогового клиентского кода (если в самом задании нет требований про вывод чего-то в консоль). Исключение – ошибки можно логировать в консоль (для тестового задания).
- Проблемы с разделением логики на абстрации: `addCaveSegment` в `store` принимает абстрактный `WSMsg` и извлекает из него данные; правильнее было бы вынести преобразование `WSMsg` в нужные данные в отдельный слой (это могут быть, например, функции-хелперы, экспортируемые из api), работающий только с преобразованием входящих данных в подходящий формат
- `setDelay(99999)` – не очень хороший способ остановить игру. Лучше сделать набор возможных состояний, в которых может находиться игра, переключаться между ними, и в зависимости от этих состояний отображать те или иные штуки ("победил"/"проиграл"/"в процессе")
- Вместо импортирова "голого" `.css` в React-компонент лучше использовать CSS-модули. Почитай, например, [эту статью](https://blog.openreplay.com/using-css-modules-in-react/), или [эту](https://medium.com/@ninooburton/css-vs-module-css-e7cee9d77f68)